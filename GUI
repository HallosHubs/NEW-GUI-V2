
    local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()
    local Window = OrionLib:MakeWindow({Name = "Hallos Gui - Da Hood ðŸ”«", HidePremium = true, IntroEnabled = false,IntroText = "Hallos gui", SaveConfig = true, ConfigFolder = "OrionTest"})
    
    OrionLib:MakeNotification({
        Name = ".",
        Content = "MADE BY Hallos#0009",
        Image = "rbxassetid://265189030",
        Time = 10
    })
    
    
    
    local Tab = Window:MakeTab({
        Name = "AimLock",
        Icon = "rbxassetid://10595687752",
        PremiumOnly = false
    })
    
    -- Save
    local Section = Tab:AddSection({
        Name = "Aimlock"
    })
    
    
    -- BUTTONS
    Tab:AddButton({
        Name = "Aimlock (C)",
        Callback = function()
                  -- main aimlock settings
    local configs = {
        main = {
            enabled = true,
            aimlockkey = "c",
            prediction = 0.134123,
            aimpart = 'HumanoidRootPart', -- Head, UpperTorso, HumanoidRootPart, LowerTorso
            notifications = true
        }
    }
    
    -- box / marker settings
    
    local boxsettings = {
        box = {
            Showbox = true,
    
            boxsize = Vector3.new(3.3, 3, 2.8), -- Box Size
            markercolor = Color3.fromRGB(1, 120, 145), -- Marrker Color
            markersize = UDim2.new(1, 0, 3, 0) -- Marker Size
        }
    }
    
    -- dont mess with anything below
    local box = Instance.new("Part", game.Workspace)
    
    local Mouse = game.Players.LocalPlayer:GetMouse()
    
    function makemarker(Parent, Adornee, Color, Size, Size2)
        local box = Instance.new("BillboardGui", Parent)
        box.Name = "PRIVATE-REWRITE!"
        box.Adornee = Adornee
        box.Size = UDim2.new(Size, Size2, Size, Size2)
        box.AlwaysOnTop = true
    
        local a = Instance.new("Frame", box)
        a.Size = boxsettings.box.markersize
        a.BackgroundColor3 = Color
    
        local g = Instance.new("UICorner", a)
        g.CornerRadius = UDim.new(50, 25)
        return (box)
    end
    
    local Plr
    Mouse.KeyDown:Connect(function(KeyPressed)
        if KeyPressed == (configs.main.aimlockkey) then
            if configs.main.enabled == true then
                configs.main.enabled = false
                if configs.main.notifications == true then
                    Plr = FindClosestUser()
                    game.StarterGui:SetCore("SendNotification", {
                        Title = "Private",
                        Text = "Unlocked;"
                    })
                end
            else
                Plr = FindClosestUser()
                configs.main.enabled = true
                if configs.main.notifications == true then
                    game.StarterGui:SetCore("SendNotification", {
                        Title = "Private",
                        Text = "Locked On;  " .. tostring(Plr.Character.Humanoid.DisplayName)
                    })
                end
            end
        end
    end)
    
    local data = game.Players:GetPlayers()
    function noob(player)
        local character
        repeat
            wait()
        until player.Character
        local handler = makemarker(guimain, player.Character:WaitForChild(configs.main.aimpart),
            Color3.fromRGB(107, 184, 255), 0.10, 8)
        handler.Name = player.Name
        player.CharacterAdded:connect(function(Char)
            handler.Adornee = Char:WaitForChild("HumanoidRootPart")
        end)
    end
    
    for i = 1, #data do
        if data[i] ~= game.Players.LocalPlayer then
            noob(data[i])
        end
    end
    
    game.Players.PlayerAdded:connect(function(Player)
        noob(Player)
    end)
    
    spawn(function()
        box.Anchored = true
        box.CanCollide = false
        box.Size = boxsettings.box.boxsize
        if boxsettings.box.Showbox == true then
            box.Transparency = 0.70
        else
            box.Transparency = 1
        end
        makemarker(box, box, boxsettings.box.markercolor, 0.40, 1)
    end)
    
    function FindClosestUser()
        local closestPlayer
        local ShortestDistance = 300
    
        for i, v in pairs(game.Players:GetPlayers()) do
            if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and
                v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") then
                local pos = game:GetService "Workspace".CurrentCamera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
                local magnitude = (Vector2.new(pos.X, pos.Y) -
                                      Vector2.new(game.Players.LocalPlayer:GetMouse().X,
                        game.Players.LocalPlayer:GetMouse().Y)).magnitude
                if magnitude < ShortestDistance then
                    closestPlayer = v
                    ShortestDistance = magnitude
                end
            end
        end
        return closestPlayer
    end
    
    game:GetService "RunService".Stepped:connect(function()
        if configs.main.enabled and Plr.Character and Plr.Character:FindFirstChild("HumanoidRootPart") then
            box.CFrame = CFrame.new(Plr.Character[configs.main.aimpart].Position +
                                        (Plr.Character.UpperTorso.Velocity * configs.main.prediction))
        else
            box.CFrame = CFrame.new(0, 9999, 0)
        end
    end)
    
    repeat
        wait()
    until game:IsLoaded()
    local mt = getrawmetatable(game)
    local old = mt.__namecall
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(...)
        local args = {...}
        if configs.main.enabled and getnamecallmethod() == "FireServer" and args[2] == "UpdateMousePos" then
            args[3] = Plr.Character[configs.main.aimpart].Position +
                          (Plr.Character[configs.main.aimpart].Velocity * configs.main.prediction)
            return old(unpack(args))
        end
        return old(...)
    end)
          end    
    })
    
    
    Tab:AddButton({
        Name = "Dotlock (C)",
        Callback = function()
                  local settings = {
        main = {
            DotEnabled = true, -- leave this true thusky pooh ;)
            Prediction = 0.11621,
            Part = "LowerTorso",
            Key = "c",
            Notifications = true,
            AirshotFunc = false
        },
        Dot = {
            Show = true,
            Color = Color3.fromRGB(128, 0, 128),
            Size = Vector3.new(0.9, 1.2, 0.9)
        }
    }
    
    
    
    
    
    
    local CurrentCamera = game:GetService "Workspace".CurrentCamera
    local Mouse = game.Players.LocalPlayer:GetMouse()
    local RunService = game:GetService("RunService")
    local Plr = game.Players.LocalPlayer
    
    local Part = Instance.new("Part", game.Workspace)
    Part.Anchored = true
    Part.CanCollide = false
    Part.Parent = game.Workspace
    Part.Shape = Enum.PartType.Ball
    Part.Size = settings.Dot.Size
    Part.Color = settings.Dot.Color
    
    if settings.Dot.Show == true then
        Part.Transparency = 0
    else
        Part.Transparency = 1
    end
    
    Mouse.KeyDown:Connect(function(KeyPressed)
        if KeyPressed == (settings.main.Key) then
            if settings.main.DotEnabled == true then
                settings.main.DotEnabled = false
                if settings.main.Notifications == true then
                    Plr = FindClosestUser()
                    game.StarterGui:SetCore("SendNotification", {
                        Title = "Hallos owns this Script",
                        Text = "No longer locked on"
                    })
                end
            else
                Plr = FindClosestUser()
                settings.main.DotEnabled = true
                if settings.main.Notifications == true then
                    game.StarterGui:SetCore("SendNotification", {
                        Text = "Locked on to:" .. tostring(Plr.Character.Humanoid.DisplayName)
                    })
                end
            end
        end
    end)
    
    function FindClosestUser()
        local closestPlayer
        local shortestDistance = math.huge
    
        for i, v in pairs(game.Players:GetPlayers()) do
            if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and
                v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") then
                local pos = CurrentCamera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
                local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
                if magnitude < shortestDistance then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
        return closestPlayer
    end
    
    RunService.Stepped:connect(function()
        if settings.main.DotEnabled and Plr.Character and Plr.Character:FindFirstChild("LowerTorso") then
            Part.CFrame = CFrame.new(Plr.Character[settings.main.Part].Position +
                                         (Plr.Character.LowerTorso.Velocity * settings.main.Prediction))
        else
            Part.CFrame = CFrame.new(0, 9999, 0)
    
        end
    end)
    
    local mt = getrawmetatable(game)
    local old = mt.__namecall
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(...)
        local args = {...}
        if settings.main.DotEnabled and getnamecallmethod() == "FireServer" and args[2] == "UpdateMousePos" then
            args[3] = Plr.Character[settings.main.Part].Position +
                          (Plr.Character[settings.main.Part].Velocity * settings.main.Prediction)
            return old(unpack(args))
        end
        return old(...)
    end)
    
    
    if settings.main.AirshotFunc == true then
        if Plr.Character.Humanoid.Jump == true and Plr.Character.Humanoid.FloorMaterial == Enum.Material.Air then
            settings.main.Part = "RightFoot"
        else
            Plr.Character:WaitForChild("Humanoid").StateChanged:Connect(function(old,new)
                if new == Enum.HumanoidStateType.Freefall then
                    settings.main.Part = "RightFoot"
                else
                    settings.main.Part = "LowerTorso"
                end
            end)
        end
    end
    
          end    
    })
    
    Tab:AddButton({
        Name = "Pink dot (C)",
        Callback = function()
                  local Settings = {
        rewrittenmain = {
            Enabled = true,
            Key = "c",
            DOT = true,
            AIRSHOT = true,
            NOTIF = false,
            AUTOPRED = false,
            FOV = math.huge,
            RESOVLER = false
        }
    }
    
    local SelectedPart = "HumanoidRootPart"
    local Prediction = true
    local PredictionValue = 0.1413
    
    
        local AnchorCount = 0
        local MaxAnchor = 50
    
        local CC = game:GetService"Workspace".CurrentCamera
        local accomidationfactor = 0.11
        local mouse = game.Players.LocalPlayer:GetMouse()
        local placemarker = Instance.new("Part", game.Workspace)
        local enabled = false
        local Plr
    
        function makemarker(Parent, Adornee, Color, Size, Size2)
            local e = Instance.new("BillboardGui", Parent)
            e.Name = "PP"
            e.Adornee = Adornee
            e.Size = UDim2.new(Size, Size2, Size, Size2)
            e.AlwaysOnTop = Settings.rewrittenmain.DOT
            local a = Instance.new("Frame", e)
            if Settings.rewrittenmain.DOT == true then
            a.Size = UDim2.new(1, 0, 1, 0)
            else
            a.Size = UDim2.new(0, 0, 0, 0)
            end
            if Settings.rewrittenmain.DOT == true then
            a.Transparency = 0
            a.BackgroundTransparency = 0
            else
            a.Transparency = 1
            a.BackgroundTransparency = 1
            end
            a.BackgroundColor3 = Color
            local g = Instance.new("UICorner", a)
            if Settings.rewrittenmain.DOT == false then
            g.CornerRadius = UDim.new(0, 0)
            else
            g.CornerRadius = UDim.new(1, 1) 
            end
            return(e)
        end
    
        
        local data = game.Players:GetPlayers()
        function noob(player)
            local character
            repeat wait() until player.Character
            local handler = makemarker(guimain, player.Character:WaitForChild(SelectedPart), Color3.fromRGB(107, 184, 255), 0.3, 3)
            handler.Name = player.Name
            player.CharacterAdded:connect(function(Char) handler.Adornee = Char:WaitForChild(SelectedPart) end)
    
    
            spawn(function()
                while wait() do
                    if player.Character then
                    end
                end
            end)
        end
    
        for i = 1, #data do
            if data[i] ~= game.Players.LocalPlayer then
                noob(data[i])
            end
        end
    
        game.Players.PlayerAdded:connect(function(Player)
            noob(Player)
        end)
    
        spawn(function()
            placemarker.Anchored = true
            placemarker.CanCollide = false
            if Settings.rewrittenmain.DOT == true then
            placemarker.Size = Vector3.new(8, 8, 8)
            else
            placemarker.Size = Vector3.new(0, 0, 0)
            end
            placemarker.Transparency = 0.75
            if Settings.rewrittenmain.DOT then
            makemarker(placemarker, placemarker, Color3.fromRGB(232, 186, 200), 0.40, 0)
            end
        end)
    
        game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
            if k == Settings.rewrittenmain.Key and Settings.rewrittenmain.Enabled then
                if enabled == true then
                    enabled = false
                    if Settings.rewrittenmain.NOTIF == true then
                        Plr = getClosestPlayerToCursor()
                    game.StarterGui:SetCore("SendNotification", {
                        Title = "";
                        Text = "Unlocked :)",
                        Duration = 5
                    })
                end
                else
                    Plr = getClosestPlayerToCursor()
                    enabled = true
                    if Settings.rewrittenmain.NOTIF == true then
    
                        game.StarterGui:SetCore("SendNotification", {
                            Title = "";
                            Text = "Target: "..tostring(Plr.Character.Humanoid.DisplayName),
                            Duration = 5
                        })
    
                    end
                end
            end
        end)
    
    
    
        function getClosestPlayerToCursor()
            local closestPlayer
            local shortestDistance = Settings.rewrittenmain.FOV
    
            for i, v in pairs(game.Players:GetPlayers()) do
                if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") then
                    local pos = CC:WorldToViewportPoint(v.Character.PrimaryPart.Position)
                    local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(mouse.X, mouse.Y)).magnitude
                    if magnitude < shortestDistance then
                        closestPlayer = v
                        shortestDistance = magnitude
                    end
                end
            end
            return closestPlayer
        end
    
        local pingvalue = nil;
        local split = nil;
        local ping = nil;
    
        game:GetService"RunService".Stepped:connect(function()
            if enabled and Plr.Character ~= nil and Plr.Character:FindFirstChild("HumanoidRootPart") then
                placemarker.CFrame = CFrame.new(Plr.Character.HumanoidRootPart.Position+(Plr.Character.HumanoidRootPart.Velocity*accomidationfactor))
            else
                placemarker.CFrame = CFrame.new(0, 9999, 0)
            end
            if Settings.rewrittenmain.AUTOPRED == true then
                 pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
                 split = string.split(pingvalue,'(')
                 ping = tonumber(split[1])
                if ping < 130 then
                    PredictionValue = 0.151
                elseif ping < 125 then
                    PredictionValue = 0.149
                elseif ping < 110 then
                    PredictionValue = 0.146
                elseif ping < 105 then
                    PredictionValue = 0.138
                elseif ping < 90 then
                    PredictionValue = 0.136
                elseif ping < 80 then
                    PredictionValue = 0.134
                elseif ping < 70 then
                    PredictionValue = 0.131
                elseif ping < 60 then
                    PredictionValue = 0.1229
                elseif ping < 50 then
                    PredictionValue = 0.1225
                elseif ping < 40 then
                    PredictionValue = 0.1256
                end
            end
        end)
    
        local mt = getrawmetatable(game)
        local old = mt.__namecall
        setreadonly(mt, false)
        mt.__namecall = newcclosure(function(...)
            local args = {...}
            if enabled and getnamecallmethod() == "FireServer" and args[2] == "UpdateMousePos" and Settings.rewrittenmain.Enabled and Plr.Character ~= nil then
    
                -- args[3] = Plr.Character.HumanoidRootPart.Position+(Plr.Character.HumanoidRootPart.Velocity*accomidationfactor)
                --[[
                if Settings.rewrittenmain.AIRSHOT == true then
                    if game.Workspace.Players[Plr.Name].Humanoid:GetState() == Enum.HumanoidStateType.Freefall then -- Plr.Character:WaitForChild("Humanoid"):GetState() == Enum.HumanoidStateType.Freefall
                        
                        --// Airshot
                        args[3] = Plr.Character.LeftFoot.Position+(Plr.Character.LeftFoot.Velocity*PredictionValue)
    
                    else
                        args[3] = Plr.Character.HumanoidRootPart.Position+(Plr.Character.HumanoidRootPart.Velocity*PredictionValue)
    
                    end
                else
                        args[3] = Plr.Character.HumanoidRootPart.Position+(Plr.Character.HumanoidRootPart.Velocity*PredictionValue)
                end
                ]]
                if Prediction == true then
                    
                args[3] = Plr.Character[SelectedPart].Position+(Plr.Character[SelectedPart].Velocity*PredictionValue)
    
                else
    
                args[3] = Plr.Character[SelectedPart].Position
    
                end
    
                return old(unpack(args))
            end
            return old(...)
        end)
    
        game:GetService("RunService").RenderStepped:Connect(function()
            if Settings.rewrittenmain.RESOVLER == true and Plr.Character ~= nil and enabled and Settings.rewrittenmain.Enabled then
            if Settings.rewrittenmain.AIRSHOT == true and enabled and Plr.Character ~= nil then
                
                if game.Workspace.Players[Plr.Name].Humanoid:GetState() == Enum.HumanoidStateType.Freefall then -- Plr.Character:WaitForChild("Humanoid"):GetState() == Enum.HumanoidStateType.Freefall
                    
                    --// Airshot
    
                    --// Anchor Check
    
                    if Plr.Character ~= nil and Plr.Character.HumanoidRootPart.Anchored == true then
                        AnchorCount = AnchorCount + 1
                        if AnchorCount >= MaxAnchor then
                            Prediction = false
                            wait(2)
                            AnchorCount = 0;
                        end
                    else
                        Prediction = true
                        AnchorCount = 0;
                    end
    
                    SelectedPart = "LeftFoot"
    
                else
                    --// Anchor Check
    
                    if Plr.Character ~= nil and Plr.Character.HumanoidRootPart.Anchored == true then
                        AnchorCount = AnchorCount + 1
                        if AnchorCount >= MaxAnchor then
                            Prediction = false
                            wait(2)
                            AnchorCount = 0;
                        end
                    else
                        Prediction = true
                        AnchorCount = 0;
                    end
    
                    SelectedPart = "HumanoidRootPart"
    
                end
                else
    
                    --// Anchor Check
    
                    if Plr.Character ~= nil and Plr.Character.HumanoidRootPart.Anchored == true then
                        AnchorCount = AnchorCount + 1
                        if AnchorCount >= MaxAnchor then
                            Prediction = false
                            wait(2)
                            AnchorCount = 0;
                        end
                    else
                        Prediction = true
                        AnchorCount = 0;
                    end
    
                    SelectedPart = "HumanoidRootPart"
                end
    
            else
                    SelectedPart = "HumanoidRootPart"
            end
        end)
    
          end    
    })
    
    Tab:AddButton({
        Name = "Black dot (Q) ",
        Callback = function()
                  
    -- 69- 0.11934
    local CC = game:GetService'Workspace'.CurrentCamera
    local Plr
    local enabled = false
    local accomidationfactor = 0.1324
    local mouse = game.Players.LocalPlayer:GetMouse()
    local placemarker = Instance.new("Part", game.Workspace)
    local guimain = Instance.new("Folder", game.CoreGui)
    
    function makemarker(Parent, Adornee, Color, Size, Size2)
        local e = Instance.new("BillboardGui", Parent)
        e.Name = "PP"
        e.Adornee = Adornee
        e.Size = UDim2.new(Size, Size2, Size, Size2)
        e.AlwaysOnTop = true
        local a = Instance.new("Frame", e)
        a.Size = UDim2.new(1, 0, 1, 0)
        a.BackgroundTransparency = 0.4
        a.BackgroundColor3 = Color
        local g = Instance.new("UICorner", a)
        g.CornerRadius = UDim.new(30, 30)
        return(e)
    end
    
    local data = game.Players:GetPlayers()
    function noob(player)
        local character
        repeat wait() until player.Character
        local handler = makemarker(guimain, player.Character:WaitForChild("LowerTorso"), Color3.fromRGB(0, 76, 153), 0.0, 0)
        handler.Name = player.Name
        player.CharacterAdded:connect(function(Char) handler.Adornee = Char:WaitForChild("LowerTorso") end)
        
        local TextLabel = Instance.new("TextLabel", handler)
        TextLabel.BackgroundTransparency = 1
        TextLabel.Position = UDim2.new(0, 0, 0, -50)
        TextLabel.Size = UDim2.new(0, 100, 0, 100)
        TextLabel.Font = Enum.Font.SourceSansSemibold
        TextLabel.TextSize = 14
        TextLabel.TextColor3 = Color3.new(1, 1, 1)
        TextLabel.TextStrokeTransparency = 0
        TextLabel.TextYAlignment = Enum.TextYAlignment.Bottom
        TextLabel.Text = 'Name: '..player.Name
        TextLabel.ZIndex = 10
        
        spawn(function()
            while wait() do
                if player.Character then
                    --TextLabel.Text = player.Name.." | Bounty: "..tostring(player:WaitForChild("leaderstats").Wanted.Value).." | "..tostring(math.floor(player.Character:WaitForChild("Humanoid").Health))
                end
            end
        end)
    end
    
    for i = 1, #data do
        if data[i] ~= game.Players.LocalPlayer then
            noob(data[i])
        end
    end
    
    game.Players.PlayerAdded:connect(function(Player)
        noob(Player)
    end)
    
    game.Players.PlayerRemoving:Connect(function(player)
        guimain[player.Name]:Destroy()
    end)
    
    spawn(function()
        placemarker.Anchored = true
        placemarker.CanCollide = false
        placemarker.Size = Vector3.new(0.1, 0.1, 0.1)
        placemarker.Transparency = 10
        makemarker(placemarker, placemarker, Color3.fromRGB(0, 0, 0), 0.55, 0)
    end)    
    
    mouse.KeyDown:Connect(function(k)
        if k ~= "q" then return end
        if enabled then
            enabled = false
           -- guimain[Plr.Name].Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        else
            enabled = true 
            Plr = getClosestPlayerToCursor()
            --guimain[Plr.Name].Frame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        end    
    end)
    
    function getClosestPlayerToCursor()
        local closestPlayer
        local shortestDistance = math.huge
    
        for i, v in pairs(game.Players:GetPlayers()) do
            if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("Head") then
                local pos = CC:WorldToViewportPoint(v.Character.PrimaryPart.Position)
                local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(mouse.X, mouse.Y)).magnitude
                if magnitude < shortestDistance then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
       return closestPlayer
    end
    
        game:GetService"RunService".Stepped:connect(function()
            if enabled and Plr.Character and Plr.Character:FindFirstChild("HumanoidRootPart") then
                placemarker.CFrame = CFrame.new(Plr.Character.HumanoidRootPart.Position+(Plr.Character.HumanoidRootPart.Velocity*accomidationfactor))
            else
                placemarker.CFrame = CFrame.new(0, 9999, 0)
            end
        end)
    
        local mt = getrawmetatable(game)
        local old = mt.__namecall
        setreadonly(mt, false)
        mt.__namecall = newcclosure(function(...)
            local args = {...}
            if enabled and getnamecallmethod() == "FireServer" and args[2] == "UpdateMousePos" then
                args[3] = Plr.Character.HumanoidRootPart.Position+(Plr.Character.HumanoidRootPart.Velocity*accomidationfactor)
                return old(unpack(args))
            end
            return old(...)
        end)
          end    
    })
    
        Tab:AddButton({
        Name = "Smooth lock (C)",
        Callback = function()
                  getgenv().OldAimPart = "UpperTorso"
    getgenv().AimPart = "UpperTorso" -- For R15 Games: {UpperTorso, LowerTorso, HumanoidRootPart, Head} | For R6 Games: {Head, Torso, HumanoidRootPart}  
        getgenv().AimlockKey = "c"
        getgenv().AimRadius = 50 -- How far away from someones character you want to lock on at
        getgenv().ThirdPerson = true 
        getgenv().FirstPerson = true
        getgenv().TeamCheck = false -- Check if Target is on your Team (True means it wont lock onto your teamates, false is vice versa) (Set it to false if there are no teams)
        getgenv().PredictMovement = true -- Predicts if they are moving in fast velocity (like jumping) so the aimbot will go a bit faster to match their speed 
        getgenv().PredictionVelocity = 6.612
        getgenv().CheckIfJumped = true
        getgenv().Smoothness = true
        getgenv().SmoothnessAmount = 0.015
    
        local Players, Uis, RService, SGui = game:GetService"Players", game:GetService"UserInputService", game:GetService"RunService", game:GetService"StarterGui";
        local Client, Mouse, Camera, CF, RNew, Vec3, Vec2 = Players.LocalPlayer, Players.LocalPlayer:GetMouse(), workspace.CurrentCamera, CFrame.new, Ray.new, Vector3.new, Vector2.new;
        local Aimlock, MousePressed, CanNotify = true, false, false;
        local AimlockTarget;
        local OldPre;
        
    
        
        getgenv().WorldToViewportPoint = function(P)
            return Camera:WorldToViewportPoint(P)
        end
        
        getgenv().WorldToScreenPoint = function(P)
            return Camera.WorldToScreenPoint(Camera, P)
        end
        
        getgenv().GetObscuringObjects = function(T)
            if T and T:FindFirstChild(getgenv().AimPart) and Client and Client.Character:FindFirstChild("Head") then 
                local RayPos = workspace:FindPartOnRay(RNew(
                    T[getgenv().AimPart].Position, Client.Character.Head.Position)
                )
                if RayPos then return RayPos:IsDescendantOf(T) end
            end
        end
        
        getgenv().GetNearestTarget = function()
            -- Credits to whoever made this, i didnt make it, and my own mouse2plr function kinda sucks
            local players = {}
            local PLAYER_HOLD  = {}
            local DISTANCES = {}
            for i, v in pairs(Players:GetPlayers()) do
                if v ~= Client then
                    table.insert(players, v)
                end
            end
            for i, v in pairs(players) do
                if v.Character ~= nil then
                    local AIM = v.Character:FindFirstChild("Head")
                    if getgenv().TeamCheck == true and v.Team ~= Client.Team then
                        local DISTANCE = (v.Character:FindFirstChild("Head").Position - game.Workspace.CurrentCamera.CFrame.p).magnitude
                        local RAY = Ray.new(game.Workspace.CurrentCamera.CFrame.p, (Mouse.Hit.p - game.Workspace.CurrentCamera.CFrame.p).unit * DISTANCE)
                        local HIT,POS = game.Workspace:FindPartOnRay(RAY, game.Workspace)
                        local DIFF = math.floor((POS - AIM.Position).magnitude)
                        PLAYER_HOLD[v.Name .. i] = {}
                        PLAYER_HOLD[v.Name .. i].dist= DISTANCE
                        PLAYER_HOLD[v.Name .. i].plr = v
                        PLAYER_HOLD[v.Name .. i].diff = DIFF
                        table.insert(DISTANCES, DIFF)
                    elseif getgenv().TeamCheck == false and v.Team == Client.Team then 
                        local DISTANCE = (v.Character:FindFirstChild("Head").Position - game.Workspace.CurrentCamera.CFrame.p).magnitude
                        local RAY = Ray.new(game.Workspace.CurrentCamera.CFrame.p, (Mouse.Hit.p - game.Workspace.CurrentCamera.CFrame.p).unit * DISTANCE)
                        local HIT,POS = game.Workspace:FindPartOnRay(RAY, game.Workspace)
                        local DIFF = math.floor((POS - AIM.Position).magnitude)
                        PLAYER_HOLD[v.Name .. i] = {}
                        PLAYER_HOLD[v.Name .. i].dist= DISTANCE
                        PLAYER_HOLD[v.Name .. i].plr = v
                        PLAYER_HOLD[v.Name .. i].diff = DIFF
                        table.insert(DISTANCES, DIFF)
                    end
                end
            end
            
            if unpack(DISTANCES) == nil then
                return nil
            end
            
            local L_DISTANCE = math.floor(math.min(unpack(DISTANCES)))
            if L_DISTANCE > getgenv().AimRadius then
                return nil
            end
            
            for i, v in pairs(PLAYER_HOLD) do
                if v.diff == L_DISTANCE then
                    return v.plr
                end
            end
            return nil
        end
        
        Mouse.KeyDown:Connect(function(a)
            if not (Uis:GetFocusedTextBox()) then 
                if a == AimlockKey and AimlockTarget == nil then
                    pcall(function()
                        if MousePressed ~= true then MousePressed = true end 
                        local Target;Target = GetNearestTarget()
                        if Target ~= nil then 
                            AimlockTarget = Target
                        end
                    end)
                elseif a == AimlockKey and AimlockTarget ~= nil then
                    if AimlockTarget ~= nil then AimlockTarget = nil end
                    if MousePressed ~= false then 
                        MousePressed = false 
                    end
                end
            end
        end)
        
        RService.RenderStepped:Connect(function()
            if getgenv().ThirdPerson == true and getgenv().FirstPerson == true then 
                if (Camera.Focus.p - Camera.CoordinateFrame.p).Magnitude > 1 or (Camera.Focus.p - Camera.CoordinateFrame.p).Magnitude <= 1 then 
                    CanNotify = true 
                else 
                    CanNotify = false 
                end
            elseif getgenv().ThirdPerson == true and getgenv().FirstPerson == false then 
                if (Camera.Focus.p - Camera.CoordinateFrame.p).Magnitude > 1 then 
                    CanNotify = true 
                else 
                    CanNotify = false 
                end
            elseif getgenv().ThirdPerson == false and getgenv().FirstPerson == true then 
                if (Camera.Focus.p - Camera.CoordinateFrame.p).Magnitude <= 1 then 
                    CanNotify = true 
                else 
                    CanNotify = false 
                end
            end
            if Aimlock == true and MousePressed == true then 
                if AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(getgenv().AimPart) then 
                    if getgenv().FirstPerson == true then
                        if CanNotify == true then
                            if getgenv().PredictMovement == true then
                                if getgenv().Smoothness == true then
                                    --// The part we're going to lerp/smoothen \\--
                                    local Main = CF(Camera.CFrame.p, AimlockTarget.Character[getgenv().AimPart].Position + AimlockTarget.Character[getgenv().AimPart].Velocity/PredictionVelocity)
                                    
                                    --// Making it work \\--
                                    Camera.CFrame = Camera.CFrame:Lerp(Main, getgenv().SmoothnessAmount, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                                else
                                    Camera.CFrame = CF(Camera.CFrame.p, AimlockTarget.Character[getgenv().AimPart].Position + AimlockTarget.Character[getgenv().AimPart].Velocity/PredictionVelocity)
                                end
                            elseif getgenv().PredictMovement == false then 
                                if getgenv().Smoothness == true then
                                    --// The part we're going to lerp/smoothen \\--
                                    local Main = CF(Camera.CFrame.p, AimlockTarget.Character[getgenv().AimPart].Position)
    
                                    --// Making it work \\--
                                    Camera.CFrame = Camera.CFrame:Lerp(Main, getgenv().SmoothnessAmount, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                                else
                                    Camera.CFrame = CF(Camera.CFrame.p, AimlockTarget.Character[getgenv().AimPart].Position)
                                end
                            end
                        end
                    end
                end
            end
             if CheckIfJumped == true then
           if AimlockTarget.Character.HuDDDDDDDDDDWmanoid.FloorMaterial == Enum.Material.Air then
        
               getgenv().AimPart = "UpperTorso"
           else
             getgenv().AimPart = getgenv().OldAimPart
    
           end
        end
    end)
          end    
    })
    
    
    local Section = Tab:AddSection({
        Name = "SilentAim (helps ur aim)"
    })
    
    Tab:AddButton({
        Name = "SilentAim",
        Callback = function()
                                            local Aiming = loadstring(game:HttpGet("https://pastebin.com/raw/aWXiZJue", true))()
                                Aiming.TeamCheck(false)
                                 
                                
                                local Workspace = game:GetService("Workspace")
                                local Players = game:GetService("Players")
                                local RunService = game:GetService("RunService")
                                local UserInputService = game:GetService("UserInputService")
                                
                                
                                local LocalPlayer = Players.LocalPlayer
                                local Mouse = LocalPlayer:GetMouse()
                                local CurrentCamera = Workspace.CurrentCamera
                                
                                local DaHoodSettings = {
                                    SilentAim = true,
                                    AimLock = false,
                                    Prediction = 0.131,
                                    AimLockKeybind = Enum.KeyCode.E
                                }
                                getgenv().DaHoodSettings = DaHoodSettings
                                
                                
                                function Aiming.Check()
                                -------------
                                    if not (Aiming.Enabled == true and Aiming.Selected ~= LocalPlayer and Aiming.SelectedPart ~= nil) then
                                        return false
                                    end
                                
                                    -- // Check if downed
                                    local Character = Aiming.Character(Aiming.Selected)
                                    local KOd = Character:WaitForChild("BodyEffects")["K.O"].Value
                                    local Grabbed = Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                                
                                    -- // Check B
                                    if (KOd or Grabbed) then
                                        return false
                                    end
                                
                                    -- //
                                    return true
                                end
                                
                                -- // Hook
                                local __index
                                __index = hookmetamethod(game, "__index", function(t, k)
                                    -- // Check if it trying to get our mouse's hit or target and see if we can use it
                                    if (t:IsA("Mouse") and (k == "Hit" or k == "Target") and Aiming.Check()) then
                                        local SelectedPart = Aiming.SelectedPart
                                
                                        -- // Hit/Target
                                        if (DaHoodSettings.SilentAim and (k == "Hit" or k == "Target")) then
                                            -- // Hit to account prediction
                                            local Hit = SelectedPart.CFrame + (SelectedPart.Velocity * DaHoodSettings.Prediction)
                                
                                            -- // Return modded val
                                            return (k == "Hit" and Hit or SelectedPart)
                                        end
                                    end
                                
                                    -- // Return
                                    return __index(t, k)
                                end)
                                
                                -- // Aimlock
                                RunService:BindToRenderStep("AimLock", 0, function()
                                    if (DaHoodSettings.AimLock and Aiming.Check() and UserInputService:IsKeyDown(DaHoodSettings.AimLockKeybind)) then
                                        -- // Vars
                                        local SelectedPart = Aiming.SelectedPart
                                
                                        -- // Hit to account prediction
                                        local Hit = SelectedPart.CFrame + (SelectedPart.Velocity * DaHoodSettings.Prediction)
                                
                                        CurrentCamera.CFrame = CFrame.lookAt(CurrentCamera.CFrame.Position, Hit.Position)
                                    end
                                    end)
          end    
    })
    
    Tab:AddButton({
        Name = "Streamable SilentAim",
        Callback = function()
                      local Aiming = loadstring(game:HttpGet("https://pastebin.com/raw/aWXiZJue", true))()
                                Aiming.TeamCheck(false)
                                 
                                
                                local Workspace = game:GetService("Workspace")
                                local Players = game:GetService("Players")
                                local RunService = game:GetService("RunService")
                                local UserInputService = game:GetService("UserInputService")
                                
                                
                                local LocalPlayer = Players.LocalPlayer
                                local Mouse = LocalPlayer:GetMouse()
                                local CurrentCamera = Workspace.CurrentCamera
                                
                                local DaHoodSettings = {
                                    SilentAim = true,
                                    AimLock = false,
                                    Prediction = 0.131,
                                    AimLockKeybind = Enum.KeyCode.E
                                }
                                getgenv().DaHoodSettings = DaHoodSettings
                                
                                
                                function Aiming.Check()
                                -------------
                                    if not (Aiming.Enabled == true and Aiming.Selected ~= LocalPlayer and Aiming.SelectedPart ~= nil) then
                                        return false
                                    end
                                
                                    -- // Check if downed
                                    local Character = Aiming.Character(Aiming.Selected)
                                    local KOd = Character:WaitForChild("BodyEffects")["K.O"].Value
                                    local Grabbed = Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                                
                                    -- // Check B
                                    if (KOd or Grabbed) then
                                        return false
                                    end
                                
                                    -- //
                                    return true
                                end
                                
                                -- // Hook
                                local __index
                                __index = hookmetamethod(game, "__index", function(t, k)
                                    -- // Check if it trying to get our mouse's hit or target and see if we can use it
                                    if (t:IsA("Mouse") and (k == "Hit" or k == "Target") and Aiming.Check()) then
                                        local SelectedPart = Aiming.SelectedPart
                                
                                        -- // Hit/Target
                                        if (DaHoodSettings.SilentAim and (k == "Hit" or k == "Target")) then
                                            -- // Hit to account prediction
                                            local Hit = SelectedPart.CFrame + (SelectedPart.Velocity * DaHoodSettings.Prediction)
                                
                                            -- // Return modded val
                                            return (k == "Hit" and Hit or SelectedPart)
                                        end
                                    end
                                
                                    -- // Return
                                    return __index(t, k)
                                end)
                                
                                -- // Aimlock
                                RunService:BindToRenderStep("AimLock", 0, function()
                                    if (DaHoodSettings.AimLock and Aiming.Check() and UserInputService:IsKeyDown(DaHoodSettings.AimLockKeybind)) then
                                        -- // Vars
                                        local SelectedPart = Aiming.SelectedPart
                                
                                        -- // Hit to account prediction
                                        local Hit = SelectedPart.CFrame + (SelectedPart.Velocity * DaHoodSettings.Prediction)
                                
                                        CurrentCamera.CFrame = CFrame.lookAt(CurrentCamera.CFrame.Position, Hit.Position)
                                    end
                                    end)
    
          end    
    })
    
    local Tab = Window:MakeTab({
        Name = "Movement",
        Icon = "rbxassetid://10595687752",
        PremiumOnly = false
    })

    Tab:AddButton({
        Name = "Speed (Z)",
        Callback = function()
            plr = game:GetService('Players').LocalPlayer
            down = true
            
            function onButton1Down(mouse)
                down = true
                while down do
                    if not down then break end
                    local char = plr.Character
                    char.HumanoidRootPart.Velocity = char.HumanoidRootPart.CFrame.lookVector * 190
                    wait()
                end
            end
            
            function onButton1Up(mouse)
                down = false
            end
            
            function onSelected(mouse)
                mouse.KeyDown:connect(function(q) if q:lower()=="z"then onButton1Down(mouse)end end)
                mouse.KeyUp:connect(function(q) if q:lower()=="z"then onButton1Up(mouse)end end)
            end
            onSelected(game.Players.LocalPlayer:GetMouse())
          end    
    })
    
    Tab:AddButton({
        Name = "Fly (Left alt go fast with ctrl",
        Callback = function()
            local Settings = {
	
                Speed = 5,
                SprintSpeed = 30,
                ToggleKey = Enum.KeyCode.LeftAlt,
                SprintKey = Enum.KeyCode.LeftControl,
                
                ForwardKey = Enum.KeyCode.W,
                LeftKey = Enum.KeyCode.A,
                BackwardKey = Enum.KeyCode.S,
                RightKey = Enum.KeyCode.D,
                UpKey = Enum.KeyCode.E,
                DownKey = Enum.KeyCode.Q,
                
            }
            
            local Screen = Instance.new("ScreenGui",game.CoreGui)
            local Distance = Instance.new("TextLabel",Screen)
            Distance.BackgroundTransparency = 1
            Distance.Size = UDim2.new(0,10,0,10)
            Distance.ZIndex = 2
            Distance.Text = "0"
            Distance.TextStrokeTransparency = .5
            Distance.TextSize = 20
            Distance.TextStrokeColor3 = Color3.fromRGB(33, 33, 33)
            Distance.Font = Enum.Font.Gotham
            Distance.TextColor3 = Color3.new(1,1,1)
            Distance.TextXAlignment = Enum.TextXAlignment.Left
            Distance.TextYAlignment = Enum.TextYAlignment.Top
            
            
            local Mouse = game.Players.LocalPlayer:GetMouse()
            local Direction = Vector3.new(0,0,0)
            local InterpolatedDir = Direction
            local Tilt = 0
            local InterpolatedTilt = Tilt
            local RunService = game:GetService("RunService")
            local Toggled = false
            local Sprinting = false
            local CameraPos = game.Workspace.CurrentCamera.CFrame.Position
            
            pcall(function()
                game.Players.LocalPlayer.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Invisicam	
            end)
            
            function Lerp(a, b, t)
                return a + (b - a) * t
            end
            
            local LastPos = nil
            
            function KeyHandler(actionName, userInputState)
                if true and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    if actionName == "Toggle" and userInputState == Enum.UserInputState.Begin then
                        Toggled = not Toggled
                        if Toggled then
                            LastPos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
                            --game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
                            game.Players.LocalPlayer.Character.Humanoid.PlatformStand = true 
                        else
                            LastPos = nil
                            game.Players.LocalPlayer.Character.Humanoid.PlatformStand = false
                            --game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
                        end
                    elseif actionName == "Forward" then
                        Tilt = userInputState == Enum.UserInputState.Begin and -20 or 0
                        Direction = Vector3.new(Direction.x,Direction.y,userInputState == Enum.UserInputState.Begin and -1 or 0)
                    elseif actionName == "Left" then
                        Direction = Vector3.new(userInputState == Enum.UserInputState.Begin and -1 or 0,Direction.y,Direction.z)
                    elseif actionName == "Backward" then
                        Tilt = userInputState == Enum.UserInputState.Begin and 20 or 0
                        Direction = Vector3.new(Direction.x,Direction.y,userInputState == Enum.UserInputState.Begin and 1 or 0)
                    elseif actionName == "Right" then
                        Direction = Vector3.new(userInputState == Enum.UserInputState.Begin and 1 or 0,Direction.y,Direction.z)
                    elseif actionName == "Up" then
                        Direction = Vector3.new(Direction.x,userInputState == Enum.UserInputState.Begin and 1 or 0,Direction.z)
                    elseif actionName == "Down" then
                        Direction = Vector3.new(Direction.x,userInputState == Enum.UserInputState.Begin and -1 or 0,Direction.z)
                    elseif actionName == "Sprint" then
                        Sprinting = userInputState == Enum.UserInputState.Begin
                    end
                end
            end
            
            
            
            game:GetService("UserInputService").InputBegan:connect(function(inputObject, gameProcessedEvent)
                
                if inputObject.KeyCode == Settings.ToggleKey then
                    KeyHandler("Toggle", Enum.UserInputState.Begin, inputObject)
                elseif inputObject.KeyCode == Settings.ForwardKey then
                    KeyHandler("Forward", Enum.UserInputState.Begin, inputObject)
                elseif inputObject.KeyCode == Settings.LeftKey then
                    KeyHandler("Left", Enum.UserInputState.Begin, inputObject)
                elseif inputObject.KeyCode == Settings.BackwardKey then
                    KeyHandler("Backward", Enum.UserInputState.Begin, inputObject)
                elseif inputObject.KeyCode == Settings.RightKey then
                    KeyHandler("Right", Enum.UserInputState.Begin, inputObject)
                elseif inputObject.KeyCode == Settings.UpKey then	
                    KeyHandler("Up", Enum.UserInputState.Begin, inputObject)
                elseif inputObject.KeyCode == Settings.DownKey then
                    KeyHandler("Down", Enum.UserInputState.Begin, inputObject)
                elseif inputObject.KeyCode == Settings.SprintKey then
                    KeyHandler("Sprint", Enum.UserInputState.Begin, inputObject)
                end
                
                
            end)
            
            
            game:GetService("UserInputService").InputEnded:connect(function(inputObject, gameProcessedEvent)
                
                if inputObject.KeyCode == Settings.ToggleKey then
                    KeyHandler("Toggle", Enum.UserInputState.End, inputObject)
                elseif inputObject.KeyCode == Settings.ForwardKey then
                    KeyHandler("Forward", Enum.UserInputState.End, inputObject)
                elseif inputObject.KeyCode == Settings.LeftKey then
                    KeyHandler("Left", Enum.UserInputState.End, inputObject)
                elseif inputObject.KeyCode == Settings.BackwardKey then
                    KeyHandler("Backward", Enum.UserInputState.End, inputObject)
                elseif inputObject.KeyCode == Settings.RightKey then
                    KeyHandler("Right", Enum.UserInputState.End, inputObject)
                elseif inputObject.KeyCode == Settings.UpKey then	
                    KeyHandler("Up", Enum.UserInputState.End, inputObject)
                elseif inputObject.KeyCode == Settings.DownKey then
                    KeyHandler("Down", Enum.UserInputState.End, inputObject)
                elseif inputObject.KeyCode == Settings.SprintKey then
                    KeyHandler("Sprint", Enum.UserInputState.End, inputObject)
                end
                
                
            end)
            
            
            RunService.RenderStepped:Connect(function()
                if Toggled and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")  then
                    for i,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                        if v:IsA("BasePart") then
                            v.Velocity = Vector3.new(0,0,0)
                        end
                    end
                    local RootPart = game.Players.LocalPlayer.Character.HumanoidRootPart
                    if LastPos then
                        Distance.Text = math.floor((LastPos-RootPart.Position).Magnitude+.5)
                        if (LastPos-RootPart.Position).Magnitude >= 350 then
                            Distance.TextColor3 = Color3.new(1,0,0)
                        else
                            Distance.TextColor3 = Color3.new(1,1,1)	
                        end
                    else
                        Distance.TextColor3 = Color3.new(1,1,1)
                        Distance.Text = 0
                    end
                    InterpolatedDir = InterpolatedDir:Lerp((Direction * (Sprinting and Settings.SprintSpeed or Settings.Speed)),.2)
                    InterpolatedTilt = Lerp(InterpolatedTilt ,Tilt* (Sprinting and 2 or 1),Tilt == 0 and .2 or .1)
                    RootPart.CFrame = RootPart.CFrame:Lerp(CFrame.new(RootPart.Position,RootPart.Position + Mouse.UnitRay.Direction) * CFrame.Angles(0,math.rad(00),0) * CFrame.new(InterpolatedDir)  * CFrame.Angles(math.rad(InterpolatedTilt),0,0),.2)
                else
                    Distance.TextColor3 = Color3.new(1,1,1)
                    Distance.Text = 0
                end	
            end)
             
          end    
    })
    
    local Tab = Window:MakeTab({
        Name = "Misc",
        Icon = "rbxassetid://10595687752",
        PremiumOnly = false
    })

    local Section = Tab:AddSection({
        Name = "AutoTalk"
    })

    
    Tab:AddButton({
        Name = "Trash talk (Y)",
        Callback = function()
            local words = {
                'ur bad',
                'seed',
                'im not locking ur just bad',
                'kid im not locking XDXDXDXD ur just bad',
                'sad',
                'sonned',
                'how did u fail to get me',
            }
            
            local player = game.Players.LocalPlayer
            local keybind = 'y'
            
            local event = game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest
            
            player:GetMouse().KeyDown:connect(function(key)
                if key == keybind then
                    event:FireServer(words[math.random(#words)], "All")
                end
            end)
          end    
    })

    Tab:AddButton({
        Name = "Chill talk (c)",
        Callback = function()
            local words = {
                'ur INSANE',
                ' HES UR SEED',
                'UR LOCKING',
                'U SONNED HIM',
                'UR BETTER',
                'demonic',
                'how are u so good',
            }
            
            local player = game.Players.LocalPlayer
            local keybind = 'c'
            
            local event = game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest
            
            player:GetMouse().KeyDown:connect(function(key)
                if key == keybind then
                    event:FireServer(words[math.random(#words)], "All")
                end
            end)
          end    
    })

    
    local Section = Tab:AddSection({
        Name = "AutoFarm"
    })

    Tab:AddButton({
        Name = "AutoFarm",
        Callback = function()
            loadstring(game:HttpGet("https://pastebin.com/raw/Zx061kiT", true))()
          end    
    })

    local Section = Tab:AddSection({
        Name = "Misc"
    })

    Tab:AddButton({
        Name = "Headless and korblox ui",
        Callback = function()
                  loadstring(game:HttpGet('https://pastebin.com/raw/H5yx10Jq'))()
          end    
    })
    
    Tab:AddButton({
        Name = "Fps and ping",
        Callback = function()
            loadstring(game:HttpGet('https://raw.githubusercontent.com/1201for/littlegui/main/FPS-Counter'))()
          end    
    })



    Tab:AddButton({
        Name = "God-Mode",
        Callback = function()
                  
local localPlayer = game:GetService('Players').LocalPlayer;
local localCharacter = localPlayer.Character;
localCharacter:FindFirstChildOfClass('Humanoid').Health = 0;
local newCharacter = localPlayer.CharacterAdded:Wait();
 local spoofFolder = Instance.new('Folder');
   spoofFolder.Parent = newCharacter;
    newCharacter:WaitForChild('RagdollConstraints'):Destroy();
             local spoofValue = Instance.new('BoolValue', newCharacter);
 spoofValue.Name = 'RagdollConstraints';
             local name = game.Players.LocalPlayer.Name
local lol =    game.Workspace:WaitForChild(name)
  local money = Instance.new("Folder",game.Players.LocalPlayer.Character);money.Name = "FULLY_LOADED_CHAR"    lol.Parent = game.Workspace.Players
game.Players.LocalPlayer.Character:WaitForChild("BodyEffects")
game.Players.LocalPlayer.Character.BodyEffects.BreakingParts:Destroy()

          end    
    })



    local Tab = Window:MakeTab({
        Name = "Esp",
        Icon = "rbxassetid://",
        PremiumOnly = false
    })


    local Section = Tab:AddSection({
        Name = "Esp"
    })



    Tab:AddButton({
        Name = "Esp no lag",
        Callback = function()
                  --[[
	 â–ˆâ–ˆâ–€â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–“â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’
	â–“â–ˆâ–ˆ â–’ â–ˆâ–ˆâ–’â–“â–ˆâ–ˆâ–’â–’ â–’ â–’ â–„â–€â–‘
	â–“â–ˆâ–ˆ â–‘â–„â–ˆ â–’â–’â–ˆâ–ˆâ–’â–‘ â–’ â–„â–€â–’â–‘ 
	â–’â–ˆâ–ˆâ–€â–€â–ˆâ–„  â–‘â–ˆâ–ˆâ–‘  â–„â–€â–’   â–‘
	â–‘â–ˆâ–ˆâ–“ â–’â–ˆâ–ˆâ–’â–‘â–ˆâ–ˆâ–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’
	â–‘ â–’â–“ â–‘â–’â–“â–‘â–‘â–“  â–‘â–’â–’ â–“â–‘â–’â–‘â–’
	  â–‘â–’ â–‘ â–’â–‘ â–’ â–‘â–‘â–‘â–’ â–’ â–‘ â–’
	  â–‘â–‘   â–‘  â–’ â–‘â–‘ â–‘ â–‘ â–‘ â–‘
	   â–‘      â–‘    â–‘ â–‘    
	             â–‘        
--]]
local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local CurrentCamera = workspace.CurrentCamera
local worldToViewportPoint = CurrentCamera.worldToViewportPoint

local HeadOff = Vector3.new(0, 0.5, 0)
local LegOff = Vector3.new(0, 3, 0)

for i, v in pairs(game.Players:GetChildren()) do
    local BoxOutline = Drawing.new("Square")
    BoxOutline.Visible = false
    BoxOutline.Color = Color3.new(0, 0, 0)
    BoxOutline.Thickness = 3
    BoxOutline.Transparency = 1
    BoxOutline.Filled = false

    local Box = Drawing.new("Square")
    Box.Visible = false
    Box.Color = Color3.new(1, 1, 1)
    Box.Thickness = 1
    Box.Transparency = 1
    Box.Filled = false

    local HealthBarOutline = Drawing.new("Square")
    HealthBarOutline.Thickness = 3
    HealthBarOutline.Filled = false
    HealthBarOutline.Color = Color3.new(0, 0, 0)
    HealthBarOutline.Transparency = 1
    HealthBarOutline.Visible = false

    local HealthBar = Drawing.new("Square")
    HealthBar.Thickness = 1
    HealthBar.Filled = false
    HealthBar.Transparency = 1
    HealthBar.Visible = false

    function boxesp()
        game:GetService("RunService").RenderStepped:Connect(
            function()
                if
                    v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and
                        v.Character:FindFirstChild("HumanoidRootPart") ~= nil and
                        v ~= lplr and
                        v.Character.Humanoid.Health > 0
                 then
                    local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

                    local RootPart = v.Character.HumanoidRootPart
                    local Head = v.Character.Head
                    local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
                    local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + HeadOff)
                    local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)

                    if onScreen then
                        BoxOutline.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                        BoxOutline.Position =
                            Vector2.new(RootPosition.X - BoxOutline.Size.X / 2, RootPosition.Y - BoxOutline.Size.Y / 2)
                        BoxOutline.Visible = true

                        Box.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                        Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                        Box.Visible = true

                        HealthBarOutline.Size = Vector2.new(2, HeadPosition.Y - LegPosition.Y)
                        HealthBarOutline.Position = BoxOutline.Position - Vector2.new(6, 0)
                        HealthBarOutline.Visible = true

                        HealthBar.Size =
                            Vector2.new(
                            2,
                            (HeadPosition.Y - LegPosition.Y) /
                                (game:GetService("Players")[v.Character.Name].NRPBS["MaxHealth"].Value /
                                    math.clamp(
                                        game:GetService("Players")[v.Character.Name].NRPBS["Health"].Value,
                                        0,
                                        game:GetService("Players")[v.Character.Name].NRPBS:WaitForChild("MaxHealth").Value
                                    ))
                        )
                        HealthBar.Position = Vector2.new(Box.Position.X - 6, Box.Position.Y + (1 / HealthBar.Size.Y))
                        HealthBar.Color =
                            Color3.fromRGB(
                            255 -
                                255 /
                                    (game:GetService("Players")[v.Character.Name].NRPBS["MaxHealth"].Value /
                                        game:GetService("Players")[v.Character.Name].NRPBS["Health"].Value),
                            255 /
                                (game:GetService("Players")[v.Character.Name].NRPBS["MaxHealth"].Value /
                                    game:GetService("Players")[v.Character.Name].NRPBS["Health"].Value),
                            0
                        )
                        HealthBar.Visible = true

                        if v.TeamColor == lplr.TeamColor then
                            --- Our Team
                            BoxOutline.Visible = false
                            Box.Visible = false
                            HealthBarOutline.Visible = false
                            HealthBar.Visible = false
                        else
                            ---Enemy Team
                            BoxOutline.Visible = true
                            Box.Visible = true
                            HealthBarOutline.Visible = true
                            HealthBar.Visible = true
                        end
                    else
                        BoxOutline.Visible = false
                        Box.Visible = false
                        HealthBarOutline.Visible = false
                        HealthBar.Visible = false
                    end
                else
                    BoxOutline.Visible = false
                    Box.Visible = false
                    HealthBarOutline.Visible = false
                    HealthBar.Visible = false
                end
            end
        )
    end
    coroutine.wrap(boxesp)()
end

game.Players.PlayerAdded:Connect(
    function(v)
        local BoxOutline = Drawing.new("Square")
        BoxOutline.Visible = false
        BoxOutline.Color = Color3.new(0, 0, 0)
        BoxOutline.Thickness = 3
        BoxOutline.Transparency = 1
        BoxOutline.Filled = false

        local Box = Drawing.new("Square")
        Box.Visible = false
        Box.Color = Color3.new(1, 1, 1)
        Box.Thickness = 1
        Box.Transparency = 1
        Box.Filled = false

        local HealthBarOutline = Drawing.new("Square")
        HealthBarOutline.Thickness = 3
        HealthBarOutline.Filled = false
        HealthBarOutline.Color = Color3.new(0, 0, 0)
        HealthBarOutline.Transparency = 1
        HealthBarOutline.Visible = false

        local HealthBar = Drawing.new("Square")
        HealthBar.Thickness = 1
        HealthBar.Filled = false
        HealthBar.Transparency = 1
        HealthBar.Visible = false

        function boxesp()
            game:GetService("RunService").RenderStepped:Connect(
                function()
                    if
                        v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and
                            v.Character:FindFirstChild("HumanoidRootPart") ~= nil and
                            v ~= lplr and
                            v.Character.Humanoid.Health > 0
                     then
                        local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

                        local RootPart = v.Character.HumanoidRootPart
                        local Head = v.Character.Head
                        local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
                        local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + HeadOff)
                        local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)

                        if onScreen then
                            BoxOutline.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                            BoxOutline.Position =
                                Vector2.new(
                                RootPosition.X - BoxOutline.Size.X / 2,
                                RootPosition.Y - BoxOutline.Size.Y / 2
                            )
                            BoxOutline.Visible = true

                            Box.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                            Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                            Box.Visible = true

                            HealthBarOutline.Size = Vector2.new(2, HeadPosition.Y - LegPosition.Y)
                            HealthBarOutline.Position = BoxOutline.Position - Vector2.new(6, 0)
                            HealthBarOutline.Visible = true

                            HealthBar.Size =
                                Vector2.new(
                                2,
                                (HeadPosition.Y - LegPosition.Y) /
                                    (game:GetService("Players")[v.Character.Name].NRPBS["MaxHealth"].Value /
                                        math.clamp(
                                            game:GetService("Players")[v.Character.Name].NRPBS["Health"].Value,
                                            0,
                                            game:GetService("Players")[v.Character.Name].NRPBS:WaitForChild("MaxHealth").Value
                                        ))
                            )
                            HealthBar.Position =
                                Vector2.new(Box.Position.X - 6, Box.Position.Y + (1 / HealthBar.Size.Y))
                            HealthBar.Color =
                                Color3.fromRGB(
                                255 -
                                    255 /
                                        (game:GetService("Players")[v.Character.Name].NRPBS["MaxHealth"].Value /
                                            game:GetService("Players")[v.Character.Name].NRPBS["Health"].Value),
                                255 /
                                    (game:GetService("Players")[v.Character.Name].NRPBS["MaxHealth"].Value /
                                        game:GetService("Players")[v.Character.Name].NRPBS["Health"].Value),
                                0
                            )
                            HealthBar.Visible = true

                            if v.TeamColor == lplr.TeamColor then
                                --- Our Team
                                BoxOutline.Visible = false
                                Box.Visible = false
                                HealthBarOutline.Visible = false
                                HealthBar.Visible = false
                            else
                                ---Enemy Team
                                BoxOutline.Visible = true
                                Box.Visible = true
                                HealthBarOutline.Visible = true
                                HealthBar.Visible = true
                            end
                        else
                            BoxOutline.Visible = false
                            Box.Visible = false
                            HealthBarOutline.Visible = false
                            HealthBar.Visible = false
                        end
                    else
                        BoxOutline.Visible = false
                        Box.Visible = false
                        HealthBarOutline.Visible = false
                        HealthBar.Visible = false
                    end
                end
            )
        end
        coroutine.wrap(boxesp)()
    end
)
          end    
    })


    local Tab = Window:MakeTab({
        Name = "Credits",
        Icon = false,
        PremiumOnly = false
    })

    Tab:AddButton({
        Name = "Owner - Hallos#0009",
        Callback = function()
                  
          end    
    })

    Tab:AddButton({
        Name = "Esp - rizzys#0001",
        Callback = function()
                  
          end    
    })

    local Section = Tab:AddSection({
        Name = "Discord"
    })

    Tab:AddButton({
        Name = "discord.gg/fN6HZY9rVq",
        Callback = function()
                  
          end    
    })

    local Section = Tab:AddSection({
        Name = "Youtube"
    })

    Tab:AddButton({
        Name = "Lookup Hallos scripts",
        Callback = function()
                  
          end    
    })


    
    OrionLib:Init()
